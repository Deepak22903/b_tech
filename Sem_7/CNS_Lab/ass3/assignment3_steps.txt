
Assignment 3 — Cryptanalysis of Double Transposition (DT) Cipher
================================================================

What we implemented
-------------------
1) **Irregular columnar transposition** (no padding): encrypt/decrypt given a column order (permutation).
2) **Double Transposition** = columnar transposition applied twice.
3) **English language scoring** with a small trigram model (add-k smoothing).
4) **Stochastic key search**: hill-climbing + simulated annealing across two permutations.
5) **Key-length search**: try ranges for c1 and c2, keep the highest-scoring plaintext.

Demonstration (already executed here)
-------------------------------------
• We generated ciphertext by encrypting a cleaned excerpt of English using random keys of sizes k1=7 and k2=6.
• The solver searched possible sizes and improved keys via random swaps.
• The best run recovered the correct sizes (7,6), recovered one key exactly and the other up to an equivalent ordering, and
  produced an essentially correct plaintext (minor leading artifact due to irregular fill conventions).

How to use with your ciphertext
-------------------------------
1) Download the script:
   - double_transposition_solver.py

2) Run from a terminal (Python 3.9+):
   python3 double_transposition_solver.py --cipher "PASTE YOUR CIPHERTEXT HERE" --c1min 5 --c1max 10 --c2min 5 --c2max 10 --restarts 8 --iters 4500

   Tips:
   • Increase --iters and --restarts for tougher texts.
   • If you have a guess for key sizes, set --c1min==--c1max and --c2min==--c2max to focus the search.
   • You can edit the DEMO_TRAIN block inside the script to include a bigger English sample to improve scoring.

Key points to write in your report
----------------------------------
• Cleaning: strip to A–Z, uppercase; length L.
• Model: trigram with add-k smoothing; score is sum of log-probs over trigrams.
• DT mechanics: first decrypt with perm2, then perm1; handle irregular last row when reconstructing column lengths.
• Search strategy: random initial perms; neighbor = random swap in perm1 or perm2; accept if better or with exp((Δ)/T).
• Convergence plots (optional): repeat runs; record best score per iteration; show best of N restarts.
• Verification: once plaintext looks grammatical, you can read the keys (perm1, perm2) and sizes (c1, c2) from the solver output.
